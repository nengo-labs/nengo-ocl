
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>nengo_ocl.simulator &#8212; NengoOCL 2.0.0.dev0 docs</title>
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,600|Rajdhani:700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
<link rel="stylesheet" href="https://www.nengo.ai/css/bootstrap.css" type="text/css">
<style>
  body .title-bar,
  body .documentation-source h1:after {
    background-color: #69c530;
  }
</style>
<!-- Google Tag Manager -->
<script>
 (function (w, d, s, l, i) {
   w[l] = w[l] || [];
   w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
   var f = d.getElementsByTagName(s)[0],
       j = d.createElement(s),
       dl = l != "dataLayer" ? "&l=" + l : "";
   j.async = true;
   j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
   f.parentNode.insertBefore(j, f);
 })(window, document, "script", "dataLayer", "GTM-KWCR2HN");
</script>
<!-- End Google Tag Manager -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://unpkg.com/scrollreveal"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stickyfill/2.1.0/stickyfill.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
<!-- From basic/layout.html -->
<script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
  
  
<script src="../../_static/underscore.js"></script>
  
  
<script src="../../_static/doctools.js"></script>
  
  
<script src="../../_static/language_data.js"></script>
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  </head><body class="bg-dark">

<header class="fixed-top header-top shadow-sm">
  <nav class="navbar navbar-expand-md navbar-light bg-white">
    <a class="navbar-brand" href="https://www.nengo.ai/">
      <img
        src="https://www.nengo.ai/design/_images/general-full-light.svg"
        alt="Nengo"
        class="logo"
      />
    </a>
    <button
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbar-collapse"
      aria-controls="navbar-collapse"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar-collapse">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/">What is Nengo?</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/examples/">Examples</a>
        </li>
        <li class="nav-item dropdown active">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-docs"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Documentation</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-docs"
          >
            
            <a class="dropdown-item" href="https://www.nengo.ai/nengo/">Nengo core</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-gui/">NengoGUI</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-dl/">NengoDL</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-spa/">NengoSPA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-extras/">NengoExtras</a>
            <a class="dropdown-item" href="https://arvoelke.github.io/nengolib-docs/">Nengolib</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-fpga/">NengoFPGA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-loihi/">NengoLoihi</a>
            <a class="dropdown-item" href="https://labs.nengo.ai/nengo-ocl/">NengoOCL</a>
            <a class="dropdown-item" href="https://github.com/project-rig/nengo_spinnaker">NengoSpiNNaker</a>
            <a class="dropdown-item" href="https://github.com/nengo-labs/nengo-mpi">NengoMPI</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/keras-spiking">KerasSpiking</a>
            <a class="dropdown-item" href="https://www.nengo.ai/pytorch-spiking">PyTorchSpiking</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/documentation/"
              >All documentation</a
            >
          </div>
        </li>
        <li class="nav-item dropdown">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-community"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Community</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-community"
          >
            <a class="dropdown-item" href="https://forum.nengo.ai">Forum</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/people/"
              >People</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/summer-school/"
              >Summer school</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/contributing/"
              >Contributing</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/publications/"
              >Publications</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/videos/"
              >Videos</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/conduct/"
              >Code of conduct</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/caa/">CAA</a>
          </div>
        </li>
        <li class="nav-item">
          <a
            class="nav-link btn btn-success btn-sm text-white"
            href="https://www.nengo.ai/getting-started/"
            >Getting started</a
          >
        </li>
      </ul>
    </div>
  </nav>
</header>
<div class="main-content gradient-top">
  <div class="container-fluid">
    <div class="row"><a class="toggle-sidenav d-block d-md-none" href="#"
  ><i class="icon-close fa fa-fw fa-arrow-left"></i
  ><i class="icon-open fa fa-fw fa-arrow-right"></i
></a>
<div role="complementary" class="sidenav col-4 col-xl-3 p-0 border-right">
  <h3 class="pt-5 px-5">
    <a href="../../index.html">
      <img
        class="img-fluid documentation-image"
        src="https://www.nengo.ai/design/_images/nengo-ocl-full-light.svg"
        alt="NengoOCL"
      />
    </a>
  </h3>
<form class="px-5 py-3 my-0 border-bottom" action="../../search.html" method="get">
  <div class="form-group form-group-single">
    <input type="text" name="q" class="form-control" placeholder="Search" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
    <button type="submit" class="btn btn-link">
      <img src="https://www.nengo.ai/img/icon-search.svg" alt="Go" />
    </button>
  </div>
</form><div class="p-5 toctree">
  
    <p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API reference</a></li>
</ul>

  
  </div>
  
</div>
      

      <div class="col-12 col-md-8 col-xl-9">
        <div class="container">
          <div class="row">
            <div class="col-10 offset-1 pb-5 documentation-source" role="main">
              
              
  <h1>Source code for nengo_ocl.simulator</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="k">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyopencl</span> <span class="k">as</span> <span class="nn">cl</span>

<span class="kn">import</span> <span class="nn">nengo</span>
<span class="kn">import</span> <span class="nn">nengo.version</span>
<span class="kn">import</span> <span class="nn">nengo.utils.numpy</span> <span class="k">as</span> <span class="nn">npext</span>
<span class="kn">from</span> <span class="nn">nengo.cache</span> <span class="k">import</span> <span class="n">get_default_decoder_cache</span>
<span class="kn">from</span> <span class="nn">nengo.exceptions</span> <span class="k">import</span> <span class="n">ReadonlyError</span><span class="p">,</span> <span class="n">SimulatorClosed</span><span class="p">,</span> <span class="n">ValidationError</span>
<span class="kn">from</span> <span class="nn">nengo.simulator</span> <span class="k">import</span> <span class="n">SimulationData</span>
<span class="kn">from</span> <span class="nn">nengo.builder.builder</span> <span class="k">import</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">nengo.builder.operator</span> <span class="k">import</span> <span class="n">Reset</span>
<span class="kn">from</span> <span class="nn">nengo.builder.signal</span> <span class="k">import</span> <span class="n">SignalDict</span>
<span class="kn">from</span> <span class="nn">nengo.utils.filter_design</span> <span class="k">import</span> <span class="n">ss2tf</span>
<span class="kn">from</span> <span class="nn">nengo.utils.numpy</span> <span class="k">import</span> <span class="n">scipy_sparse</span>
<span class="kn">from</span> <span class="nn">nengo.utils.progress</span> <span class="k">import</span> <span class="n">ProgressTracker</span><span class="p">,</span> <span class="n">Progress</span>
<span class="kn">from</span> <span class="nn">nengo.utils.stdlib</span> <span class="k">import</span> <span class="n">groupby</span>

<span class="kn">from</span> <span class="nn">nengo_ocl.builder</span> <span class="k">import</span> <span class="n">Builder</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.raggedarray</span> <span class="k">import</span> <span class="n">RaggedArray</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.clraggedarray</span> <span class="k">import</span> <span class="n">CLRaggedArray</span><span class="p">,</span> <span class="n">to_device</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.clra_gemv</span> <span class="k">import</span> <span class="n">plan_block_gemv</span><span class="p">,</span> <span class="n">plan_sparse_dot_inc</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.clra_nonlinearities</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">plan_timeupdate</span><span class="p">,</span>
    <span class="n">plan_reset</span><span class="p">,</span>
    <span class="n">plan_copy</span><span class="p">,</span>
    <span class="n">plan_slicedcopy</span><span class="p">,</span>
    <span class="n">plan_direct</span><span class="p">,</span>
    <span class="n">plan_lif</span><span class="p">,</span>
    <span class="n">plan_lif_rate</span><span class="p">,</span>
    <span class="n">plan_rectified_linear</span><span class="p">,</span>
    <span class="n">plan_spiking_rectified_linear</span><span class="p">,</span>
    <span class="n">plan_sigmoid</span><span class="p">,</span>
    <span class="n">plan_probes</span><span class="p">,</span>
    <span class="n">plan_linearfilter</span><span class="p">,</span>
    <span class="n">plan_elementwise_inc</span><span class="p">,</span>
    <span class="n">create_rngs</span><span class="p">,</span>
    <span class="n">init_rngs</span><span class="p">,</span>
    <span class="n">get_dist_enums_params</span><span class="p">,</span>
    <span class="n">plan_whitenoise</span><span class="p">,</span>
    <span class="n">plan_presentinput</span><span class="p">,</span>
    <span class="n">plan_conv2d</span><span class="p">,</span>
    <span class="n">plan_bcm</span><span class="p">,</span>
    <span class="n">plan_oja</span><span class="p">,</span>
    <span class="n">plan_voja</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.operators</span> <span class="k">import</span> <span class="n">MultiDotInc</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.plan</span> <span class="k">import</span> <span class="n">BasePlan</span><span class="p">,</span> <span class="n">PythonPlan</span><span class="p">,</span> <span class="n">Plans</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.planners</span> <span class="k">import</span> <span class="n">greedy_planner</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.ast_conversion</span> <span class="k">import</span> <span class="n">OCL_Function</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.utils</span> <span class="k">import</span> <span class="n">get_closures</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">stable_unique</span><span class="p">,</span> <span class="n">Timer</span>
<span class="kn">from</span> <span class="nn">nengo_ocl.version</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">bad_nengo_versions</span><span class="p">,</span>
    <span class="n">latest_nengo_version</span><span class="p">,</span>
    <span class="n">latest_nengo_version_info</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">PROFILING_ENABLE</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">command_queue_properties</span><span class="o">.</span><span class="n">PROFILING_ENABLE</span>


<span class="k">class</span> <span class="nc">ViewBuilder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">rarray</span><span class="p">,</span> <span class="n">is_sparse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span> <span class="o">=</span> <span class="p">{</span><span class="n">bb</span><span class="p">:</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bases</span><span class="p">)}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rarray</span> <span class="o">=</span> <span class="n">rarray</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape0s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape1s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride0s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride1s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_A_views</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X_views</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_YYB_views</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># if None accept dense and sparse signals,</span>
        <span class="c1"># otherwise dense (False) or sparse (True) only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="o">=</span> <span class="n">is_sparse</span>

    <span class="k">def</span> <span class="nf">append_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># we already have this signal (either a base, or an existing view)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
            <span class="c1"># -- it is not a view, and not OK. All non-views should already be in `sidx`</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only append views of known signals&quot;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">sig</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">sig</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
        <span class="n">shape0</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">shape1</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rarray</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">sig</span><span class="o">.</span><span class="n">elemoffset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape0s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape1s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride0s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">elemstrides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape0</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride1s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">elemstrides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape1</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">sig</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_views_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rarray</span><span class="p">):</span>
        <span class="n">rarray</span><span class="o">.</span><span class="n">add_views</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape0s</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape1s</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stride0s</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stride1s</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_views</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">all_views</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">MultiDotInc</span><span class="p">)):</span>
            <span class="n">A_views</span><span class="p">,</span> <span class="n">X_views</span><span class="p">,</span> <span class="n">Y_view</span><span class="p">,</span> <span class="n">Y_in_view</span><span class="p">,</span> <span class="n">beta_view</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get_views</span><span class="p">()</span>
            <span class="n">multidotinc_views</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">A_views</span>
                <span class="o">+</span> <span class="n">X_views</span>
                <span class="o">+</span> <span class="p">[</span><span class="n">Y_view</span><span class="p">,</span> <span class="n">Y_in_view</span><span class="p">]</span>
                <span class="o">+</span> <span class="p">([</span><span class="n">beta_view</span><span class="p">]</span> <span class="k">if</span> <span class="n">beta_view</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">sparse</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">multidotinc_views</span><span class="p">)</span>

            <span class="n">all_views</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">multidotinc_views</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A_views</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_views</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_X_views</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">X_views</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_YYB_views</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Y_view</span><span class="p">,</span> <span class="n">Y_in_view</span><span class="p">,</span> <span class="n">beta_view</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">view</span> <span class="ow">in</span> <span class="n">all_views</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">sparse</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>


<div class="viewcode-block" id="Simulator"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator">[docs]</a><span class="k">class</span> <span class="nc">Simulator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulator for running Nengo models in OpenCL.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network, dt, seed, model</span>
<span class="sd">        These parameters are the same as in `nengo.Simulator`.</span>
<span class="sd">    context : `pyopencl.Context` (optional)</span>
<span class="sd">        OpenCL context specifying which device(s) to run on. By default, we</span>
<span class="sd">        will create a context by calling `pyopencl.create_some_context`</span>
<span class="sd">        and use this context as the default for all subsequent instances.</span>
<span class="sd">    n_prealloc_probes : int (optional)</span>
<span class="sd">        Number of timesteps to buffer when probing. Larger numbers mean less</span>
<span class="sd">        data transfer with the device (faster), but use more device memory.</span>
<span class="sd">    profiling : boolean (optional)</span>
<span class="sd">        If ``True``, ``print_profiling()`` will show profiling information.</span>
<span class="sd">        By default, will check the environment variable ``NENGO_OCL_PROFILING``</span>
<span class="sd">    if_python_code : &#39;none&#39; | &#39;warn&#39; | &#39;error&#39;</span>
<span class="sd">        How the simulator should react if a Python function cannot be converted</span>
<span class="sd">        to OpenCL code.</span>
<span class="sd">    planner : callable</span>
<span class="sd">        A function to plan operator order. See ``nengo_ocl.planners``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># --- Store the result of create_some_context so we don&#39;t recreate it</span>
    <span class="n">some_context</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">Array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">RaggedArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listofarrays</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CLRaggedArray</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">listofarrays</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>  <span class="c1"># noqa: C901</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">network</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_prealloc_probes</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">profiling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">if_python_code</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">planner</span><span class="o">=</span><span class="n">greedy_planner</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># --- create these first since they are used in __del__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># --- check version</span>
        <span class="k">if</span> <span class="n">nengo</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version_info</span> <span class="ow">in</span> <span class="n">bad_nengo_versions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;This simulator does not support Nengo version </span><span class="si">%s</span><span class="s2">. Upgrade &quot;</span>
                <span class="s2">&quot;with &#39;pip install --upgrade --no-deps nengo&#39;.&quot;</span> <span class="o">%</span> <span class="n">nengo</span><span class="o">.</span><span class="n">__version__</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">nengo</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="n">latest_nengo_version_info</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;This version of `nengo_ocl` has not been tested &quot;</span>
                <span class="s2">&quot;with your `nengo` version (</span><span class="si">%s</span><span class="s2">). The latest fully &quot;</span>
                <span class="s2">&quot;supported version is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span> <span class="n">latest_nengo_version</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># --- arguments/attributes</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Simulator</span><span class="o">.</span><span class="n">some_context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No context argument was provided to nengo_ocl.Simulator&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calling pyopencl.create_some_context() for you now:&quot;</span><span class="p">)</span>
            <span class="n">Simulator</span><span class="o">.</span><span class="n">some_context</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">create_some_context</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">profiling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">profiling</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;NENGO_OCL_PROFILING&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">Simulator</span><span class="o">.</span><span class="n">some_context</span> <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profiling</span> <span class="o">=</span> <span class="n">profiling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">CommandQueue</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="n">PROFILING_ENABLE</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiling</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">if_python_code</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;warn&quot;</span><span class="p">,</span> <span class="s2">&quot;error&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> not a valid value for `if_python_code`&quot;</span> <span class="o">%</span> <span class="n">if_python_code</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">if_python_code</span> <span class="o">=</span> <span class="n">if_python_code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_prealloc_probes</span> <span class="o">=</span> <span class="n">n_prealloc_probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_bar</span> <span class="o">=</span> <span class="n">progress_bar</span>

        <span class="c1"># --- Nengo build</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">nengo_timer</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
                    <span class="n">dt</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">),</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, dt=</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">dt</span><span class="p">),</span>
                    <span class="n">decoder_cache</span><span class="o">=</span><span class="n">get_default_decoder_cache</span><span class="p">(),</span>
                    <span class="n">builder</span><span class="o">=</span><span class="n">Builder</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

            <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Build the network into the model</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nengo build in </span><span class="si">%0.3f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="n">nengo_timer</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

        <span class="c1"># --- operators</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">planner_timer</span><span class="p">:</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">operators</span><span class="p">)</span>

            <span class="c1"># convert DotInc and Copy to MultiDotInc</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">MultiDotInc</span><span class="o">.</span><span class="n">convert_to</span><span class="p">,</span> <span class="n">operators</span><span class="p">))</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="n">MultiDotInc</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>

            <span class="c1"># plan the order of operations, combining where appropriate</span>
            <span class="n">op_groups</span> <span class="o">=</span> <span class="n">planner</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">([</span><span class="n">typ</span> <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">op_groups</span> <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="n">Reset</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="p">),</span> <span class="s2">&quot;All resets not planned together&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="n">operators</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_groups</span> <span class="o">=</span> <span class="n">op_groups</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Planning in </span><span class="si">%0.3f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="n">planner_timer</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">signals_timer</span><span class="p">:</span>
            <span class="c1"># Initialize signals</span>
            <span class="n">all_signals</span> <span class="o">=</span> <span class="n">stable_unique</span><span class="p">(</span>
                <span class="n">sig</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">all_signals</span>
            <span class="p">)</span>
            <span class="n">all_bases</span> <span class="o">=</span> <span class="n">stable_unique</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">base</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">all_signals</span><span class="p">)</span>

            <span class="c1"># create SignalDict and add all signals from operators</span>
            <span class="n">sigdict</span> <span class="o">=</span> <span class="n">SignalDict</span><span class="p">()</span>  <span class="c1"># map from Signal.base -&gt; ndarray</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">:</span>
                <span class="n">op</span><span class="o">.</span><span class="n">init_signals</span><span class="p">(</span><span class="n">sigdict</span><span class="p">)</span>

            <span class="c1"># separate dense and sparse signals</span>
            <span class="n">sparse_signals</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_signals</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">sparse</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sparse_signals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Sparse signal views not yet supported&quot;</span><span class="p">)</span>

            <span class="n">dense_bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">all_bases</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">sparse</span><span class="p">]</span>
            <span class="n">sparse_bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">all_bases</span> <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">sparse</span><span class="p">]</span>

            <span class="c1"># --- create dense data on host and add views</span>
            <span class="n">dense_data</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the actual arrays (from `sigdict`) for each dense base</span>

            <span class="c1"># reshape any arrays &gt; 2D (note that any views on these bases will still be</span>
            <span class="c1"># &gt; 2D, and will fail when we add them in the view builder. Currently, &gt; 2D</span>
            <span class="c1"># signals are only used in Convolution, and we never make views.)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_reshapes</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># TODO: use this (eg. in `self.signals` to reshape)</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">dense_bases</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">sigdict</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base_reshapes</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dense_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">dense_data</span> <span class="o">=</span> <span class="n">RaggedArray</span><span class="p">(</span>
                <span class="n">dense_data</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sb</span> <span class="ow">in</span> <span class="n">dense_bases</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">view_builder</span> <span class="o">=</span> <span class="n">ViewBuilder</span><span class="p">(</span><span class="n">dense_bases</span><span class="p">,</span> <span class="n">dense_data</span><span class="p">,</span> <span class="n">is_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">view_builder</span><span class="o">.</span><span class="n">setup_views</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">probes</span><span class="p">:</span>
                <span class="n">view_builder</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sig</span><span class="p">[</span><span class="n">probe</span><span class="p">][</span><span class="s2">&quot;in&quot;</span><span class="p">])</span>
            <span class="n">view_builder</span><span class="o">.</span><span class="n">add_views_to</span><span class="p">(</span><span class="n">dense_data</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">all_bases</span> <span class="o">=</span> <span class="n">dense_bases</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">view_builder</span><span class="o">.</span><span class="n">sidx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A_views</span> <span class="o">=</span> <span class="n">view_builder</span><span class="o">.</span><span class="n">_A_views</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_X_views</span> <span class="o">=</span> <span class="n">view_builder</span><span class="o">.</span><span class="n">_X_views</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_YYB_views</span> <span class="o">=</span> <span class="n">view_builder</span><span class="o">.</span><span class="n">_YYB_views</span>
            <span class="k">del</span> <span class="n">view_builder</span>

            <span class="c1"># --- set up sparse data</span>
            <span class="n">spmatrix</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">scipy_sparse</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scipy_sparse</span><span class="o">.</span><span class="n">spmatrix</span>
            <span class="n">sparse_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigdict</span><span class="p">[</span><span class="n">sb</span><span class="p">]</span> <span class="k">for</span> <span class="n">sb</span> <span class="ow">in</span> <span class="n">sparse_bases</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spmatrix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Sparse matrices not supported without Scipy&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sparse_data</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;All sparse matrices must be instances of `scipy.sparse.spmatrix`&quot;</span>
                <span class="p">)</span>

            <span class="n">sparse_sidx_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sparse_bases</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse_sidx</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">sparse_sidx_map</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sparse_signals</span><span class="p">}</span>

            <span class="c1"># Copy data to device</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="n">CLRaggedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">dense_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse_data</span> <span class="o">=</span> <span class="n">sparse_data</span>  <span class="c1"># sparse data currently handled on host</span>

            <span class="c1"># Provide an interface to simulation data (build output and probe data)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_probe_outputs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>  <span class="c1"># init with build output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">SimulationData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_probe_outputs</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Signals in </span><span class="si">%0.3f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="n">signals_timer</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

        <span class="c1"># --- set seed</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">network</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">npext</span><span class="o">.</span><span class="n">maxint</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># --- create list of plans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raggedarrays_to_reset</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cl_rngs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python_rngs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">plans_timer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">op_type</span><span class="p">,</span> <span class="n">op_list</span> <span class="ow">in</span> <span class="n">op_groups</span><span class="p">:</span>
                <span class="n">plans</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plan_op_group</span><span class="p">(</span><span class="n">op_type</span><span class="p">,</span> <span class="n">op_list</span><span class="p">))</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plan_probes</span><span class="p">())</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Plans in </span><span class="si">%0.3f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="n">plans_timer</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

        <span class="c1"># -- create object to execute list of plans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plans</span> <span class="o">=</span> <span class="n">Plans</span><span class="p">(</span><span class="n">plans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiling</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># all randomness set, should no longer be used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_probes</span><span class="p">()</span>  <span class="c1"># clears probes from previous model builds</span>

    <span class="k">def</span> <span class="nf">_create_cl_rngs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seeds</span><span class="p">):</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">npext</span><span class="o">.</span><span class="n">maxint</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seeds</span><span class="p">]</span>
        <span class="n">cl_rngs</span> <span class="o">=</span> <span class="n">create_rngs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seeds</span><span class="p">))</span>
        <span class="n">init_rngs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">cl_rngs</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cl_rngs</span><span class="p">[</span><span class="n">cl_rngs</span><span class="p">]</span> <span class="o">=</span> <span class="n">seeds</span>
        <span class="k">return</span> <span class="n">cl_rngs</span>

    <span class="k">def</span> <span class="nf">_reset_rngs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">rngs</span><span class="p">,</span> <span class="n">seeds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cl_rngs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">init_rngs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">rngs</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">rng</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_rngs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rng</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise a ResourceWarning if we are deallocated while open.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Simulator with model=</span><span class="si">%s</span><span class="s2"> was deallocated while open. Please &quot;</span>
                <span class="s2">&quot;close simulators manually to ensure resources are properly &quot;</span>
                <span class="s2">&quot;freed.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="ne">ResourceWarning</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return internally shaped signals, which are always 2d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;NengoOCL simulator does not yet support pickling&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;NengoOCL simulator does not yet support pickling&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(float) The time step of the simulator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>

    <span class="nd">@dt</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dummy</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ReadonlyError</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s2">&quot;dt&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(int) The current time step of the simulator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_steps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(float) The current time of the simulator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@property</span>  <span class="c1"># noqa: C901</span>
    <span class="k">def</span> <span class="nf">signals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get/set [properly-shaped] signal value (either 0d, 1d, or 2d)&quot;&quot;&quot;</span>

        <span class="k">class</span> <span class="nc">Accessor</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_bases</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_bases</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">raw</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">raw</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
                <span class="n">incoming</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">incoming</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span> <span class="o">=</span> <span class="n">incoming</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span> <span class="o">==</span> <span class="n">incoming</span><span class="o">.</span><span class="n">shape</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span> <span class="o">=</span> <span class="n">incoming</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">incoming</span><span class="o">.</span><span class="n">shape</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span> <span class="o">=</span> <span class="n">incoming</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">self_</span><span class="p">):</span>
                <span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">self_</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">self_</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">file</span><span class="o">=</span><span class="n">sio</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Accessor</span><span class="p">()</span>

    <span class="c1"># --- Simulation functions (see ``nengo.Simulator`` for interface)</span>
<div class="viewcode-block" id="Simulator.clear_probes"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.clear_probes">[docs]</a>    <span class="k">def</span> <span class="nf">clear_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear all probe histories.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_probe_outputs</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># clear probe cache</span></div>

<div class="viewcode-block" id="Simulator.close"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Closes the simulator.</span>

<span class="sd">        Any call to `.Simulator.run`, `.Simulator.run_steps`,</span>
<span class="sd">        `.Simulator.step`, and `.Simulator.reset` on a closed simulator raises</span>
<span class="sd">        a `nengo.exceptions.SimulatorClosed` exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plans</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raggedarrays_to_reset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cl_rngs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy all probed signals to buffers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_step_time</span><span class="p">()</span>

        <span class="n">plan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span>
        <span class="k">if</span> <span class="n">plan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># nothing to probe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
        <span class="n">bufpositions</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">cl_bufpositions</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">probe</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">probes</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sig</span><span class="p">[</span><span class="n">probe</span><span class="p">][</span><span class="s2">&quot;in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">n_buffered</span> <span class="o">=</span> <span class="n">bufpositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_buffered</span><span class="p">:</span>
                <span class="c1"># XXX: this syntax retrieves *ALL* of Y from the device</span>
                <span class="c1">#      because the :n_buffered only works on the ndarray</span>
                <span class="c1">#      *after* it has been transferred.</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="n">n_buffered</span><span class="p">]</span>
                <span class="n">shaped</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_buffered</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_probe_outputs</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shaped</span><span class="p">)</span>
        <span class="n">plan</span><span class="o">.</span><span class="n">cl_bufpositions</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_probe_step_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reset_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span><span class="o">.</span><span class="n">cl_bufpositions</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_probe_outputs</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_probe_step_time</span><span class="p">()</span>

<div class="viewcode-block" id="Simulator.reset"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the simulator state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seed : None</span>
<span class="sd">            Not implemented. Changing the simulator seed during reset is not supported</span>
<span class="sd">            by NengoOCL.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SimulatorClosed</span><span class="p">(</span><span class="s2">&quot;Cannot reset closed Simulator.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Seed changing not implemented&quot;</span><span class="p">)</span>

        <span class="c1"># reset signals</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_bases</span><span class="p">:</span>
            <span class="c1"># TODO: copy all data on at once</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="o">.</span><span class="n">readonly</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">base</span><span class="p">]]</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">initial_value</span>

        <span class="k">for</span> <span class="n">clra</span><span class="p">,</span> <span class="n">ra</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raggedarrays_to_reset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># TODO: copy all data on at once</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clra</span><span class="p">)):</span>
                <span class="n">clra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_rngs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_probes</span><span class="p">()</span></div>

<div class="viewcode-block" id="Simulator.run"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_in_seconds</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simulate for the given length of time.</span>

<span class="sd">        If the given length of time is not a multiple of ``dt``,</span>
<span class="sd">        it will be rounded to the nearest ``dt``. For example, if ``dt``</span>
<span class="sd">        is 0.001 and ``run`` is called with ``time_in_seconds=0.0006``,</span>
<span class="sd">        the simulator will advance one timestep, resulting in the actual</span>
<span class="sd">        simulator time being 0.001.</span>

<span class="sd">        The given length of time must be positive. The simulator cannot</span>
<span class="sd">        be run backwards.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_in_seconds : float</span>
<span class="sd">            Amount of time to run the simulation for. Must be positive.</span>
<span class="sd">        progress_bar : bool or `nengo.utils.progress.ProgressBar`, optional</span>
<span class="sd">            Progress bar for displaying the progress of the simulation run.</span>

<span class="sd">            If True, the default progress bar will be used.</span>
<span class="sd">            If False, the progress bar will be disabled.</span>
<span class="sd">            For more control over the progress bar, pass in a</span>
<span class="sd">            `nengo.utils.progress.ProgressBar` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_in_seconds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
                <span class="s2">&quot;Must be positive (got </span><span class="si">%g</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time_in_seconds</span><span class="p">,),</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;time_in_seconds&quot;</span>
            <span class="p">)</span>

        <span class="n">steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time_in_seconds</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">steps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> results in running for 0 timesteps. Simulator &quot;</span>
                <span class="s2">&quot;still at time </span><span class="si">%g</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time_in_seconds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Running </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%f</span><span class="s2"> seconds, or </span><span class="si">%d</span><span class="s2"> steps&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                <span class="n">time_in_seconds</span><span class="p">,</span>
                <span class="n">steps</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_steps</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulator.run_steps"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.run_steps">[docs]</a>    <span class="k">def</span> <span class="nf">run_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
        <span class="sd">&quot;&quot;&quot;Simulate for the given number of ``dt`` steps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int</span>
<span class="sd">            Number of steps to run the simulation for.</span>
<span class="sd">        progress_bar : bool or `nengo.utils.progress.ProgressBar`, optional</span>
<span class="sd">            Progress bar for displaying the progress of the simulation run.</span>

<span class="sd">            If True, the default progress bar will be used.</span>
<span class="sd">            If False, the progress bar will be disabled.</span>
<span class="sd">            For more control over the progress bar, pass in a</span>
<span class="sd">            `nengo.utils.progress.ProgressBar` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SimulatorClosed</span><span class="p">(</span><span class="s2">&quot;Simulator cannot run because it is closed.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">24</span><span class="p">:</span>
            <span class="c1"># since n_steps is float32, point at which `n_steps == n_steps + 1`</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle more than 2**24 steps&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">steps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot run for negative steps (got </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">steps</span><span class="p">,))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># -- precondition: the probe buffers have been drained</span>
            <span class="n">bufpositions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span><span class="o">.</span><span class="n">cl_bufpositions</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">bufpositions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">progress_bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">progress_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_bar</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressTracker</span><span class="p">(</span>
                <span class="n">progress_bar</span><span class="p">,</span> <span class="n">Progress</span><span class="p">(</span><span class="s2">&quot;Simulating&quot;</span><span class="p">,</span> <span class="s2">&quot;Simulation&quot;</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressTracker</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s2">&quot;Simulating&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressTracker</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">progress</span><span class="p">:</span>
            <span class="c1"># we will go through steps of the simulator in groups of up to B at a time,</span>
            <span class="c1"># draining the probe buffers after each group of B</span>
            <span class="k">while</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_steps_between_probes</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_plans</span><span class="o">.</span><span class="n">call_n_times</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_probe</span><span class="p">()</span>
                <span class="n">steps</span> <span class="o">-=</span> <span class="n">B</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span> <span class="s2">&quot;total_progress&quot;</span><span class="p">):</span>
                    <span class="n">progress</span><span class="o">.</span><span class="n">total_progress</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">B</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">progress</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">B</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_profiling</span><span class="p">()</span></div>

<div class="viewcode-block" id="Simulator.step"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advance the simulator by 1 step (``dt`` seconds).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_steps</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulator.trange"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.trange">[docs]</a>    <span class="k">def</span> <span class="nf">trange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a vector of times matching probed data.</span>

<span class="sd">        Note that the range does not start at 0 as one might expect, but at</span>
<span class="sd">        the first timestep (i.e., ``dt``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_every : float, optional</span>
<span class="sd">            The sampling period of the probe to create a range for.</span>
<span class="sd">            If None, a time value for every ``dt`` will be produced.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">               Renamed from dt to sample_every</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sample_every</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify both `dt` and `sample_every`. &quot;</span>
                    <span class="s2">&quot;Use `sample_every` only.&quot;</span><span class="p">,</span>
                    <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;dt&quot;</span><span class="p">,</span>
                    <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`dt` is deprecated. Use `sample_every` instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
            <span class="p">)</span>
            <span class="n">sample_every</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="n">period</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">sample_every</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sample_every</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="n">steps</span><span class="p">[</span><span class="n">steps</span> <span class="o">%</span> <span class="n">period</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span></div>

    <span class="c1"># --- Planning</span>
    <span class="k">def</span> <span class="nf">plan_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">probes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_steps_between_probes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_prealloc_probes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_prealloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_prealloc_probes</span>

            <span class="n">probes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">probes</span>
            <span class="n">periods</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">sample_every</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">p</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span>
            <span class="p">]</span>

            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sig</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s2">&quot;in&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">]]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_prealloc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sig</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s2">&quot;in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">cl_plan</span> <span class="o">=</span> <span class="n">plan_probes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_steps_between_probes</span> <span class="o">=</span> <span class="n">n_prealloc</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">periods</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cl_probe_plan</span> <span class="o">=</span> <span class="n">cl_plan</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cl_plan</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_steps_between_probes</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">plan_op_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_type</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;plan_&quot;</span> <span class="o">+</span> <span class="n">op_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)(</span><span class="n">ops</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plan_PreserveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>  <span class="c1"># LEGACY</span>
        <span class="c1"># This op was removed in Nengo version 2.3.1+, but remains here</span>
        <span class="c1"># for compatibility with older versions of Nengo.</span>
        <span class="k">return</span> <span class="p">[]</span>  <span class="c1"># do nothing</span>

    <span class="k">def</span> <span class="nf">plan_MultiDotInc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">constant_bs</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">_float_beta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">vector_bs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">op</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span>
            <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">_signal_beta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">_signal_beta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constant_bs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector_bs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A_views</span><span class="p">[</span><span class="n">op</span><span class="p">],</span>
            <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X_views</span><span class="p">[</span><span class="n">op</span><span class="p">],</span>
            <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_YYB_views</span><span class="p">[</span><span class="n">op</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_YYB_views</span><span class="p">[</span><span class="n">op</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">constant_b_gemvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sig_gemv</span><span class="p">(</span>
            <span class="n">constant_bs</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">beta</span><span class="o">=</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">_float_beta</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">constant_bs</span><span class="p">],</span>
            <span class="n">gamma</span><span class="o">=</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">gamma</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">constant_bs</span><span class="p">],</span>
            <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;c-beta-</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">constant_bs</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">vector_b_gemvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sig_gemv</span><span class="p">(</span>
            <span class="n">vector_bs</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">beta</span><span class="o">=</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_YYB_views</span><span class="p">[</span><span class="n">op</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">gamma</span><span class="o">=</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">gamma</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">vector_bs</span><span class="p">],</span>
            <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;v-beta-</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector_bs</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">constant_b_gemvs</span> <span class="o">+</span> <span class="n">vector_b_gemvs</span>

    <span class="k">def</span> <span class="nf">_sig_gemv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ops</span><span class="p">,</span>
        <span class="n">A_js_fn</span><span class="p">,</span>
        <span class="n">X_js_fn</span><span class="p">,</span>
        <span class="n">Y_fn</span><span class="p">,</span>
        <span class="n">Y_in_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">all_data</span><span class="p">,</span> <span class="n">sidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span>
        <span class="n">A_js</span> <span class="o">=</span> <span class="n">RaggedArray</span><span class="p">([[</span><span class="n">sidx</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">A_js_fn</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">X_js</span> <span class="o">=</span> <span class="n">RaggedArray</span><span class="p">([[</span><span class="n">sidx</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">X_js_fn</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">Y_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Y_fn</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
        <span class="n">Y_in_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Y_in_fn</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span> <span class="k">if</span> <span class="n">Y_in_fn</span> <span class="k">else</span> <span class="n">Y_sigs</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[[</span><span class="n">sidx</span><span class="p">[</span><span class="n">sig</span><span class="p">]</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">Y_sigs</span><span class="p">]]</span>
        <span class="n">Y_in</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[[</span><span class="n">sidx</span><span class="p">[</span><span class="n">sig</span><span class="p">]</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">Y_in_sigs</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">beta</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">RaggedArray</span><span class="p">([</span><span class="n">sidx</span><span class="p">[</span><span class="n">beta</span><span class="p">(</span><span class="n">o</span><span class="p">)]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">rval</span> <span class="o">=</span> <span class="n">plan_block_gemv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">all_data</span><span class="p">,</span>
            <span class="n">A_js</span><span class="p">,</span>
            <span class="n">all_data</span><span class="p">,</span>
            <span class="n">X_js</span><span class="p">,</span>
            <span class="n">beta</span><span class="p">,</span>
            <span class="n">Y</span><span class="p">,</span>
            <span class="n">Y_in</span><span class="o">=</span><span class="n">Y_in</span><span class="p">,</span>
            <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">rval</span><span class="o">.</span><span class="n">plans</span>

    <span class="k">def</span> <span class="nf">plan_TimeUpdate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="p">(</span><span class="n">op</span><span class="p">,)</span> <span class="o">=</span> <span class="n">ops</span>
        <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">step</span><span class="p">]]]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">time</span><span class="p">]]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_timeupdate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_Reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">dst</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">values</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_SlicedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>  <span class="c1"># LEGACY</span>
        <span class="c1"># This op was removed in Nengo version 2.3.1+, but remains here</span>
        <span class="c1"># for compatibility with older versions of Nengo.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan_Copy</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plan_Copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">noslice</span> <span class="o">=</span> <span class="bp">Ellipsis</span> <span class="k">if</span> <span class="n">legacy</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># LEGACY</span>
        <span class="n">copies</span><span class="p">,</span> <span class="n">ops</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span>
            <span class="n">ops</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">src_slice</span> <span class="ow">is</span> <span class="n">noslice</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">dst_slice</span> <span class="ow">is</span> <span class="n">noslice</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">copies</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">src</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">copies</span><span class="p">]]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">dst</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">copies</span><span class="p">]]</span>
            <span class="n">incs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">inc</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">copies</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plan_copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">incs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ops</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ary</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ary</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span>
                <span class="bp">Ellipsis</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">i</span>
            <span class="p">]</span>
            <span class="n">xinds</span> <span class="o">=</span> <span class="p">[</span><span class="n">inds</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">src_slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
            <span class="n">yinds</span> <span class="o">=</span> <span class="p">[</span><span class="n">inds</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">dst_slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>

            <span class="n">dupl</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dupl</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xinds</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">dupl</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">yinds</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Duplicates in indices&quot;</span><span class="p">)</span>

            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">src</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">dst</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
            <span class="n">Xinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span><span class="n">xinds</span><span class="p">)</span>
            <span class="n">Yinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span><span class="n">yinds</span><span class="p">)</span>
            <span class="n">incs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">inc</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plan_slicedcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Xinds</span><span class="p">,</span> <span class="n">Yinds</span><span class="p">,</span> <span class="n">incs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">plan_ElementwiseInc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">A</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">X</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">Y</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_elementwise_inc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_SparseDotInc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">scipy_sparse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># currently gives one plan per sparse operation instead of combining them all</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">A</span><span class="p">]]</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            <span class="n">A_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">A_indptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">A_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">X</span><span class="p">]]]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">Y</span><span class="p">]]]</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">plan_sparse_dot_inc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">A_indices</span><span class="p">,</span> <span class="n">A_indptr</span><span class="p">,</span> <span class="n">A_data</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">plan_SimPyFunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">op</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
        <span class="c1"># ^ NOTE: Groups functions based on equality `==`, not identity `is`.</span>
        <span class="c1">#   I think this is what we want in all cases.</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_plan_python_fn</span><span class="p">(</span>
                    <span class="n">fn</span><span class="p">,</span>
                    <span class="n">ts</span><span class="o">=</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">t</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">group</span><span class="p">],</span>
                    <span class="n">xs</span><span class="o">=</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">group</span><span class="p">],</span>
                    <span class="n">ys</span><span class="o">=</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">group</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">_plan_python_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">)</span>

        <span class="n">signal_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">sig</span><span class="p">:</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">fn_name</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># group by number of x dims</span>
        <span class="n">signals</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">signal_size</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># --- try to turn Python function into OCL code</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unplanned_signals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">group</span><span class="p">)</span>

            <span class="c1"># if any functions have no output, must do them in Python</span>
            <span class="n">y_dim</span> <span class="o">=</span> <span class="n">signal_size</span><span class="p">(</span><span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">y_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_found_python_code</span><span class="p">(</span>
                    <span class="s2">&quot;Function </span><span class="si">%r</span><span class="s2"> could not be converted to OCL &quot;</span>
                    <span class="s2">&quot;since it has no outputs.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fn_name</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">unplanned_signals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="c1"># try to get OCL code</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_python_code</span> <span class="o">==</span> <span class="s2">&quot;error&quot;</span><span class="p">:</span>
                <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plan_fn_in_ocl</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plan_fn_in_ocl</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_found_python_code</span><span class="p">(</span>
                        <span class="s2">&quot;Function </span><span class="si">%r</span><span class="s2"> could not be converted to OCL due to </span><span class="si">%s%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">fn_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">unplanned_signals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">))</span>

        <span class="c1"># --- do remaining unplanned signals in Python</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unplanned_signals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">unplanned_signals</span><span class="p">)</span>
            <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plan_fn_in_python</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">_found_python_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_python_code</span> <span class="o">==</span> <span class="s2">&quot;error&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_python_code</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_plan_fn_in_ocl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">):</span>
        <span class="n">signal_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">sig</span><span class="p">:</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">vector_dims</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span>
        <span class="n">unit_stride</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">es</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">t_in</span> <span class="o">=</span> <span class="n">tt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">x_in</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">x_dim</span> <span class="o">=</span> <span class="n">signal_size</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y_dim</span> <span class="o">=</span> <span class="n">signal_size</span><span class="p">(</span><span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">x_dim</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y_dim</span> <span class="o">!=</span> <span class="mi">0</span>  <span class="c1"># should either be None or &gt; 0</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">signal_size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">x_dim</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">signal_size</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">y_dim</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yy</span><span class="p">)</span>

        <span class="c1"># check signal input and output shape (implicitly checks</span>
        <span class="c1"># for indexing errors)</span>
        <span class="k">if</span> <span class="n">x_in</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">vector_dims</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xx</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">unit_stride</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">elemstrides</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xx</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">vector_dims</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yy</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">unit_stride</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">elemstrides</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yy</span><span class="p">)</span>

        <span class="c1"># try to get OCL code</span>
        <span class="n">in_dims</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">t_in</span> <span class="k">else</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">([</span><span class="n">x_dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">x_in</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="n">ocl_fn</span> <span class="o">=</span> <span class="n">OCL_Function</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">in_dims</span><span class="o">=</span><span class="n">in_dims</span><span class="p">,</span> <span class="n">out_dim</span><span class="o">=</span><span class="n">y_dim</span><span class="p">)</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="n">ocl_fn</span><span class="o">.</span><span class="n">translator</span><span class="o">.</span><span class="n">arg_names</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">t_in</span><span class="p">:</span>  <span class="c1"># append time</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tt</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">x_in</span><span class="p">:</span>  <span class="c1"># append x</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xx</span><span class="p">]])</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yy</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">plan_direct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span>
            <span class="n">ocl_fn</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
            <span class="n">ocl_fn</span><span class="o">.</span><span class="n">init</span><span class="p">,</span>
            <span class="n">input_names</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">output</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">fn_name</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_plan_fn_in_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">):</span>
        <span class="n">t_in</span> <span class="o">=</span> <span class="n">tt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">t_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time</span><span class="p">]</span>
        <span class="n">x_idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xx</span><span class="p">]</span>
        <span class="n">y_idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yy</span><span class="p">]</span>
        <span class="n">ix_iy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">y_idx</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">m2v</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># matrix to vector, if appropriate</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">v2m</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># vector to matrix, if appropriate</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">step</span><span class="p">():</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">t_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">t_in</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">ix_iy</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">if</span> <span class="n">t_in</span> <span class="k">else</span> <span class="p">[]</span>
                <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="n">m2v</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">ix</span><span class="p">])]</span> <span class="k">if</span> <span class="n">ix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">v2m</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">PythonPlan</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;python_fn&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">fn_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plan_SimNeurons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_ops</span><span class="p">):</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">all_ops</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">neuron_class</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;_plan_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">neuron_class</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
                <span class="n">plans</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)(</span><span class="n">ops</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported neuron type &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">neuron_class</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">_plan_LIF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">min_voltage</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;LIF min voltage&quot;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_rc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_lif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">amp</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_plan_LIFRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_rc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_lif_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">amp</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_plan_AdaptiveLIF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_rc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">tau_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">inc_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">inc_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">plan_lif</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">tau_n</span><span class="o">=</span><span class="n">tau_n</span><span class="p">,</span> <span class="n">inc_n</span><span class="o">=</span><span class="n">inc_n</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_plan_AdaptiveLIFRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_rc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">tau_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">inc_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">inc_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">plan_lif_rate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">tau_n</span><span class="o">=</span><span class="n">tau_n</span><span class="p">,</span> <span class="n">inc_n</span><span class="o">=</span><span class="n">inc_n</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_plan_RectifiedLinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_rectified_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">amp</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_plan_SpikingRectifiedLinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_spiking_rectified_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">amp</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_plan_Sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">tau_ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ref</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_SimProcess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_ops</span><span class="p">):</span>
        <span class="n">class_groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">all_ops</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="p">))</span>
        <span class="n">plan_groups</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">python_ops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">class_groups</span><span class="p">:</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">process_class</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="n">attrname</span> <span class="o">=</span> <span class="s2">&quot;_plan_&quot;</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>
                    <span class="n">plan_groups</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">python_ops</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

        <span class="n">process_plans</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">plan_groups</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)(</span><span class="n">ops</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">python_plans</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">python_ops</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_python_process</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">process_plans</span> <span class="o">+</span> <span class="n">python_plans</span>

    <span class="k">def</span> <span class="nf">_plan_python_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">get_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">make_state</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">make_step</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span>
        <span class="p">)</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_python_fn</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">input</span><span class="p">],</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">])</span>
        <span class="p">(</span><span class="n">plan</span><span class="p">,)</span> <span class="o">=</span> <span class="n">plans</span>  <span class="c1"># should only be one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python_rngs</span><span class="p">[</span><span class="n">rng</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">_plan_LinearFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">make_state</span><span class="p">(</span>
                <span class="n">op</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">make_step</span><span class="p">(</span>
                <span class="n">op</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span>
            <span class="p">)</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="c1"># Nengo 3.0 uses state-space filters. For now, convert back to transfer function</span>
        <span class="c1"># to use existing kernel. Future work: rewrite plan_linearfilter for state-space</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">D</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># special case for a feedthrough</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">D</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">ss2tf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

            <span class="c1"># --- preprocessing from Nengo v2.8.0: LinearFilter.make_step</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
                    <span class="s2">&quot;First element of the denominator must be 1&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;den&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span>
                <span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">num</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">den</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># drop first element (equal to 1)</span>

            <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="n">dens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span><span class="n">dens</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">input</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">Xbuf0</span> <span class="o">=</span> <span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">sizes</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">sizes</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">Ybuf0</span> <span class="o">=</span> <span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">sizes</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">sizes</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">Xbuf</span> <span class="o">=</span> <span class="n">CLRaggedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">Xbuf0</span><span class="p">)</span>
        <span class="n">Ybuf</span> <span class="o">=</span> <span class="n">CLRaggedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">Ybuf0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raggedarrays_to_reset</span><span class="p">[</span><span class="n">Xbuf</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xbuf0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raggedarrays_to_reset</span><span class="p">[</span><span class="n">Ybuf</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ybuf0</span>
        <span class="k">return</span> <span class="n">plan_linearfilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Xbuf</span><span class="p">,</span> <span class="n">Ybuf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_plan_WhiteNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">input</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">)</span>

        <span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">seed</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
        <span class="n">cl_rngs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_cl_rngs</span><span class="p">(</span><span class="n">seeds</span><span class="p">)</span>

        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;inc&quot;</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">enums</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">get_dist_enums_params</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">dist</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">enums</span> <span class="o">=</span> <span class="n">CLRaggedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">enums</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">CLRaggedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_whitenoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">enums</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">cl_rngs</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_plan_FilteredNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_plan_WhiteSignal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">step</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">signals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">op</span><span class="o">.</span><span class="n">input</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">get_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">make_state</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">make_step</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">signals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_closures</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="s2">&quot;signal&quot;</span><span class="p">])</span>

        <span class="n">signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_presentinput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">signals</span><span class="p">,</span> <span class="n">dt</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_plan_PresentInput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">process</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">step</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">pres_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">presentation_time</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">])</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_presentinput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">pres_t</span><span class="o">=</span><span class="n">pres_t</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_ConvInc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">dimensions</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">channels_last</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">channels_last</span>
            <span class="k">assert</span> <span class="n">channels_last</span> <span class="o">==</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">input_shape</span><span class="o">.</span><span class="n">channels_last</span>
            <span class="k">assert</span> <span class="n">channels_last</span> <span class="o">==</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">output_shape</span><span class="o">.</span><span class="n">channels_last</span>

            <span class="n">shape_in</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">input_shape</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">shape_out</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">output_shape</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">kernel_shape</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">kernel_size</span>
            <span class="n">strides</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">strides</span>
            <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># add extra (vertical) dimension to make it 2D convolution</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_in</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">kernel_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kernel_shape</span><span class="p">)</span>
                <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">channels_last</span><span class="p">:</span>
                    <span class="n">shape_in</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_in</span><span class="p">)</span>
                    <span class="n">shape_out</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape_out</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shape_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape_in</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">shape_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape_out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape_out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">plans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">plan_conv2d</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">getitem_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">X</span><span class="p">]),</span>
                    <span class="n">Y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">getitem_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">Y</span><span class="p">]),</span>
                    <span class="n">filters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">getitem_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">W</span><span class="p">]),</span>
                    <span class="n">biases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">shape_in</span><span class="o">=</span><span class="n">shape_in</span><span class="p">,</span>
                    <span class="n">shape_out</span><span class="o">=</span><span class="n">shape_out</span><span class="p">,</span>
                    <span class="n">kernel_shape</span><span class="o">=</span><span class="n">kernel_shape</span><span class="p">,</span>
                    <span class="n">padding</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">padding</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                    <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                    <span class="n">channels_last</span><span class="o">=</span><span class="n">channels_last</span><span class="p">,</span>
                    <span class="n">conv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">plans</span>

    <span class="k">def</span> <span class="nf">plan_SimPES</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">op</span><span class="o">.</span><span class="n">encoders</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span>
        <span class="p">),</span> <span class="s2">&quot;SimPES encoders should be handled by custom `builder.py:build_pes`&quot;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">pre_filtered</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">error</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">delta</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="o">-</span><span class="n">op</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="n">op</span><span class="o">.</span><span class="n">pre_filtered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">plan_elementwise_inc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">outer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">plan_SimBCM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">pre_filtered</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">post_filtered</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">theta</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">delta</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_bcm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_SimOja</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">pre_filtered</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">post_filtered</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">delta</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">beta</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">plan_oja</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">plan_SimVoja</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">pre_decoded</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">post_filtered</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">encoders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">scaled_encoders</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">delta</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">learning_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">sidx</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">learning_signal</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]]</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RaggedArray</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dt</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">plan_voja</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">encoders</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">learning_signal</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">alpha</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">print_plans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Plans &quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">plan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plans</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">plan</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">plan</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">plan</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<div class="viewcode-block" id="Simulator.print_profiling"><a class="viewcode-back" href="../../api.html#nengo_ocl.Simulator.print_profiling">[docs]</a>    <span class="k">def</span> <span class="nf">print_profiling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
        <span class="sd">&quot;&quot;&quot;Print recorded profiling information in a sorted table.</span>

<span class="sd">        To enable profiling, pass the ``profiling=True`` argument when creating</span>
<span class="sd">        the ``Simulator``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort : column to sort by (negative number sorts ascending)</span>
<span class="sd">            (0 = n_calls, 1 = runtime, 2 = q-time, 3 = subtime)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiling</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Profiling not enabled!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># make and sort table</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unknowns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plans</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">BasePlan</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ctimes</span><span class="p">)</span>
                <span class="n">calls_per_sec</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">n_calls</span> <span class="o">/</span> <span class="n">t</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">gfps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># gigaflops / sec</span>
                <span class="n">gbps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># gigabytes / sec</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">flops_per_call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gfps</span> <span class="o">=</span> <span class="mf">1e-9</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">flops_per_call</span> <span class="o">*</span> <span class="n">calls_per_sec</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">bw_per_call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gbps</span> <span class="o">=</span> <span class="mf">1e-9</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">bw_per_call</span> <span class="o">*</span> <span class="n">calls_per_sec</span>
                <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">n_calls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">gfps</span><span class="p">,</span> <span class="n">gbps</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unknowns</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;cumtime&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;unknown&gt;&quot;</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">sort</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">table</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">sort</span><span class="p">)],</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

        <span class="c1"># print table</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Profiling &quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%8s</span><span class="s2">|</span><span class="si">%10s</span><span class="s2">|</span><span class="si">%10s</span><span class="s2">|</span><span class="si">%10s</span><span class="s2">|&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;n_calls&quot;</span><span class="p">,</span> <span class="s2">&quot;runtime&quot;</span><span class="p">,</span> <span class="s2">&quot;GF/s&quot;</span><span class="p">,</span> <span class="s2">&quot;GB/s&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%8d</span><span class="s2">|</span><span class="si">%10.3f</span><span class="s2">|</span><span class="si">%10.3f</span><span class="s2">|</span><span class="si">%10.3f</span><span class="s2">| </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>

        <span class="c1"># totals totals</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">table</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">wmean</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">tm</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">tm</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">tm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">if</span> <span class="n">tm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;totals:</span><span class="se">\t</span><span class="si">%2.3f</span><span class="se">\t</span><span class="si">%2.3f</span><span class="se">\t</span><span class="si">%2.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">wmean</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="n">wmean</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
        <span class="p">)</span>

        <span class="c1"># print unknowns</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unknowns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">unknowns</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span></div></div>
</pre></div>

            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div><footer class="text-light footer-main gradient-bottom">
  <p class="small text-center mb-0">
    <a class="no-hover-line" href="https://appliedbrainresearch.com">
      <img
        src="https://appliedbrainresearch.com/img/logo-blue-notext.svg"
        height="48"
      />
    </a>
    <a href="https://www.nengo.ai/">What is Nengo?</a>
    <a href="https://www.nengo.ai/examples/">Examples</a>
    <a href="https://www.nengo.ai/documentation/">Documentation</a>
    <a href="https://www.nengo.ai/getting-started/">Getting started</a>
    <a href="https://www.nengo.ai/privacy/">Privacy</a>
  </p>
  <p class="small text-center mb-0">&copy; Applied Brain Research</p>
</footer>
<script>
  var elements = document.querySelectorAll('.sidenav');
  Stickyfill.add(elements);
</script>
<script>
  ScrollReveal().reveal(".fade-in", {
      scale: 0.85,
      duration: 1000,
      delay: 250,
      interval: 50
  });
</script>
<script>
  $('a.toggle-sidenav').on('click', function(e) {
    e.preventDefault();
    if ( $(this).hasClass('active') ) {
      $(this).removeClass('active');
      $('.sidenav').removeClass('open');
    } else {
      $(this).addClass('active');
      $('.sidenav').addClass('open');
    }
  });
</script>
<script>
  var lists = document.querySelectorAll('.toctree ul');
  lists.forEach((ul) => {
      ul.classList.add("nav");
  });
  var links = document.querySelectorAll('.toctree a');
  links.forEach((link) => {
      link.classList.add("nav-link");
  });
  $("body").scrollspy({target: ".sidenav"});
</script>
  </body>
</html>